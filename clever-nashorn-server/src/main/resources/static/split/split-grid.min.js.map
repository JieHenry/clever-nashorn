{"version":3,"file":"split-grid.min.js","sources":["../src/gridUtil.js","../src/index.js"],"sourcesContent":["export const getStyles = (rule, ownRules, matchedRules) =>\n    [...ownRules, ...matchedRules]\n        .map(r => r.style[rule])\n        .filter(style => style !== undefined && style !== '')\n\nexport const getTrackValues = (unit, sizes) =>\n    sizes.reduce((accum, size, i) => {\n        if (size.endsWith(unit)) {\n            // eslint-disable-next-line no-param-reassign\n            accum[i] = Number(size.slice(0, -1 * unit.length))\n        }\n\n        return accum\n    }, {})\n\nexport const getGapValue = (unit, size) => {\n    if (size.endsWith(unit)) {\n        return Number(size.slice(0, -1 * unit.length))\n    }\n    return null\n}\n\nexport const getComputedValues = sizes =>\n    sizes.map(size => Number(size.slice(0, -2)))\n\nexport const getTypeFromTrackValue = value => {\n    if (value.endsWith('px')) return 'px'\n    if (value.endsWith('fr')) return 'fr'\n    if (value.endsWith('%')) return '%'\n    if (value === 'auto') return 'auto'\n    return null\n}\n\nexport const getSizeAtTrack = (index, tracks, gap, end) => {\n    const newIndex = end ? index + 1 : index\n    const trackSum = tracks\n        .slice(0, newIndex)\n        .reduce((accum, value) => accum + value, 0)\n    const gapSum = gap ? index * gap : 0\n\n    return trackSum + gapSum\n}\n\nexport const firstNonZero = obj => {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i += 1) {\n        if (obj[keys[i]] > 0) {\n            return keys[i]\n        }\n    }\n    return null\n}\n\nexport const combineTracks = (oldTracks, newTracks) => {\n    const old = oldTracks ? oldTracks.split(' ') : []\n\n    Object.keys(newTracks).forEach(track => {\n        if (track > old.length - 1) {\n            throw new Error(\n                `Unable to set size of track index ${track}, there are only ${\n                    old.length\n                } tracks in the grid layout.`,\n            )\n        }\n\n        old[track] = newTracks[track]\n    })\n\n    return old.join(' ')\n}\n","import {\n    getStyles,\n    getTrackValues,\n    getComputedValues,\n    getGapValue,\n    getTypeFromTrackValue,\n    getSizeAtTrack,\n    firstNonZero,\n} from './gridUtil'\n\nconst gridTemplatePropColumns = 'grid-template-columns'\nconst gridTemplatePropRows = 'grid-template-rows'\n\nconst getMatchedCSSRules = el =>\n    []\n        .concat(\n            ...Array.from(el.ownerDocument.styleSheets).map(s => {\n                let rules = []\n\n                try {\n                    rules = Array.from(s.cssRules || [])\n                } catch (e) {\n                    // Ignore results on security error\n                }\n\n                return rules\n            }),\n        )\n        .filter(r => {\n            let matches = false\n            try {\n                matches = el.matches(r.selectorText)\n            } catch (e) {\n                // Ignore matching erros\n            }\n\n            return matches\n        })\n\nconst NOOP = () => false\n\nconst defaultWriteStyle = (element, gridTemplateProp, style) => {\n    // eslint-disable-next-line no-param-reassign\n    element.style[gridTemplateProp] = style\n}\n\nconst getOption = (options, propName, def) => {\n    const value = options[propName]\n    if (value !== undefined) {\n        return value\n    }\n    return def\n}\n\nclass Gutter {\n    constructor(direction, options, parentOptions) {\n        this.direction = direction\n        this.element = options.element\n        this.track = options.track\n        this.trackTypes = {}\n\n        if (direction === 'column') {\n            this.gridTemplateProp = gridTemplatePropColumns\n            this.gridGapProp = 'grid-column-gap'\n            this.cursor = getOption(\n                parentOptions,\n                'columnCursor',\n                getOption(parentOptions, 'cursor', 'col-resize'),\n            )\n            this.snapOffset = getOption(\n                parentOptions,\n                'columnSnapOffset',\n                getOption(parentOptions, 'snapOffset', 30),\n            )\n            this.dragInterval = getOption(\n                parentOptions,\n                'columnDragInterval',\n                getOption(parentOptions, 'dragInterval', 1),\n            )\n            this.clientAxis = 'clientX'\n            this.optionStyle = getOption(parentOptions, 'gridTemplateColumns')\n        } else if (direction === 'row') {\n            this.gridTemplateProp = gridTemplatePropRows\n            this.gridGapProp = 'grid-row-gap'\n            this.cursor = getOption(\n                parentOptions,\n                'rowCursor',\n                getOption(parentOptions, 'cursor', 'row-resize'),\n            )\n            this.snapOffset = getOption(\n                parentOptions,\n                'rowSnapOffset',\n                getOption(parentOptions, 'snapOffset', 30),\n            )\n            this.dragInterval = getOption(\n                parentOptions,\n                'rowDragInterval',\n                getOption(parentOptions, 'dragInterval', 1),\n            )\n            this.clientAxis = 'clientY'\n            this.optionStyle = getOption(parentOptions, 'gridTemplateRows')\n        }\n\n        this.onDragStart = getOption(parentOptions, 'onDragStart', NOOP)\n        this.onDragEnd = getOption(parentOptions, 'onDragEnd', NOOP)\n        this.onDrag = getOption(parentOptions, 'onDrag', NOOP)\n        this.writeStyle = getOption(\n            parentOptions,\n            'writeStyle',\n            defaultWriteStyle,\n        )\n\n        this.startDragging = this.startDragging.bind(this)\n        this.stopDragging = this.stopDragging.bind(this)\n        this.drag = this.drag.bind(this)\n\n        this.minSizeStart = options.minSizeStart\n        this.minSizeEnd = options.minSizeEnd\n\n        if (options.element) {\n            this.element.addEventListener('mousedown', this.startDragging)\n            this.element.addEventListener('touchstart', this.startDragging)\n        }\n    }\n\n    getDimensions() {\n        const {\n            width,\n            height,\n            top,\n            bottom,\n            left,\n            right,\n        } = this.grid.getBoundingClientRect()\n\n        if (this.direction === 'column') {\n            this.start = top\n            this.end = bottom\n            this.size = height\n        } else if (this.direction === 'row') {\n            this.start = left\n            this.end = right\n            this.size = width\n        }\n    }\n\n    getSizeAtTrack(track, end) {\n        return getSizeAtTrack(\n            track,\n            this.computedPixels,\n            this.computedGapPixels,\n            end,\n        )\n    }\n\n    getSizeOfTrack(track) {\n        return this.computedPixels[track]\n    }\n\n    getRawTracks() {\n        const tracks = getStyles(\n            this.gridTemplateProp,\n            [this.grid],\n            getMatchedCSSRules(this.grid),\n        )\n        if (!tracks.length) {\n            if (this.optionStyle) return this.optionStyle\n\n            throw Error('Unable to determine grid template tracks from styles.')\n        }\n        return tracks[0]\n    }\n\n    getGap() {\n        const gap = getStyles(\n            this.gridGapProp,\n            [this.grid],\n            getMatchedCSSRules(this.grid),\n        )\n        if (!gap.length) {\n            return null\n        }\n        return gap[0]\n    }\n\n    getRawComputedTracks() {\n        return window.getComputedStyle(this.grid)[this.gridTemplateProp]\n    }\n\n    getRawComputedGap() {\n        return window.getComputedStyle(this.grid)[this.gridGapProp]\n    }\n\n    setTracks(raw) {\n        this.tracks = raw.split(' ')\n        this.trackTypes = this.tracks.reduce((accum, value, i) => {\n            // eslint-disable-next-line no-param-reassign\n            accum[i] = getTypeFromTrackValue(value)\n            return accum\n        }, {})\n    }\n\n    setComputedTracks(raw) {\n        this.computedTracks = raw.split(' ')\n        this.computedPixels = getComputedValues(this.computedTracks)\n    }\n\n    setGap(raw) {\n        this.gap = raw\n    }\n\n    setComputedGap(raw) {\n        this.computedGap = raw\n        this.computedGapPixels = getGapValue('px', this.computedGap) || 0\n    }\n\n    getMousePosition(e) {\n        if ('touches' in e) return e.touches[0][this.clientAxis]\n        return e[this.clientAxis]\n    }\n\n    startDragging(e) {\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault()\n\n        if (this.element) {\n            this.grid = this.element.parentNode\n        } else {\n            this.grid = e.target.parentNode\n        }\n\n        this.getDimensions()\n        this.setComputedTracks(this.getRawComputedTracks())\n        this.setTracks(this.getRawTracks())\n        this.setGap(this.getGap())\n        this.setComputedGap(this.getRawComputedGap())\n\n        const trackPercentage = getTrackValues('%', this.tracks)\n        const trackFr = getTrackValues('fr', this.tracks)\n\n        this.totalFrs = Object.keys(trackFr).length\n\n        if (this.totalFrs) {\n            const track = firstNonZero(trackFr)\n\n            if (track !== undefined) {\n                this.frToPixels = this.computedPixels[track] / trackFr[track]\n            }\n        }\n\n        if (Object.keys(trackPercentage).length) {\n            const track = firstNonZero(trackPercentage)\n\n            if (track !== undefined) {\n                this.percentageToPixels =\n                    this.computedPixels[track] / trackPercentage[track]\n            }\n        }\n\n        // get start of gutter track\n        const gutterStart = this.getSizeAtTrack(this.track, false) + this.start\n        this.dragStartOffset = this.getMousePosition(e) - gutterStart\n\n        this.aTrack = this.track - 1\n\n        if (this.track < this.tracks.length - 1) {\n            this.bTrack = this.track + 1\n        } else {\n            throw Error(\n                `Invalid track index: ${\n                    this.track\n                }. Track must be between two other tracks and only ${\n                    this.tracks.length\n                } tracks were found.`,\n            )\n        }\n\n        this.aTrackStart = this.getSizeAtTrack(this.aTrack, false) + this.start\n        this.bTrackEnd = this.getSizeAtTrack(this.bTrack, true) + this.start\n\n        // Set the dragging property of the pair object.\n        this.dragging = true\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        window.addEventListener('mouseup', this.stopDragging)\n        window.addEventListener('touchend', this.stopDragging)\n        window.addEventListener('touchcancel', this.stopDragging)\n        window.addEventListener('mousemove', this.drag)\n        window.addEventListener('touchmove', this.drag)\n\n        // Disable selection. Disable!\n        this.grid.addEventListener('selectstart', NOOP)\n        this.grid.addEventListener('dragstart', NOOP)\n\n        this.grid.style.userSelect = 'none'\n        this.grid.style.webkitUserSelect = 'none'\n        this.grid.style.MozUserSelect = 'none'\n        this.grid.style.pointerEvents = 'none'\n\n        // Set the cursor at multiple levels\n        this.grid.style.cursor = this.cursor\n        window.document.body.style.cursor = this.cursor\n\n        this.onDragStart(this.direction, this.track)\n    }\n\n    stopDragging() {\n        this.dragging = false\n\n        // Remove the stored event listeners. This is why we store them.\n        this.cleanup()\n\n        this.onDragEnd(this.direction, this.track)\n\n        if (this.needsDestroy) {\n            if (this.element) {\n                this.element.removeEventListener(\n                    'mousedown',\n                    this.startDragging,\n                )\n                this.element.removeEventListener(\n                    'touchstart',\n                    this.startDragging,\n                )\n            }\n            this.destroyCb()\n            this.needsDestroy = false\n            this.destroyCb = null\n        }\n    }\n\n    drag(e) {\n        let mousePosition = this.getMousePosition(e)\n\n        const gutterSize = this.getSizeOfTrack(this.track)\n        const minMousePosition =\n            this.aTrackStart +\n            this.minSizeStart +\n            this.dragStartOffset +\n            this.computedGapPixels\n        const maxMousePosition =\n            this.bTrackEnd -\n            this.minSizeEnd -\n            this.computedGapPixels -\n            (gutterSize - this.dragStartOffset)\n        const minMousePositionOffset = minMousePosition + this.snapOffset\n        const maxMousePositionOffset = maxMousePosition - this.snapOffset\n\n        if (mousePosition < minMousePositionOffset) {\n            mousePosition = minMousePosition\n        }\n\n        if (mousePosition > maxMousePositionOffset) {\n            mousePosition = maxMousePosition\n        }\n\n        if (mousePosition < minMousePosition) {\n            mousePosition = minMousePosition\n        } else if (mousePosition > maxMousePosition) {\n            mousePosition = maxMousePosition\n        }\n\n        let aTrackSize =\n            mousePosition -\n            this.aTrackStart -\n            this.dragStartOffset -\n            this.computedGapPixels\n        let bTrackSize =\n            this.bTrackEnd -\n            mousePosition +\n            this.dragStartOffset -\n            gutterSize -\n            this.computedGapPixels\n\n        if (this.dragInterval > 1) {\n            const aTrackSizeIntervaled =\n                Math.round(aTrackSize / this.dragInterval) * this.dragInterval\n            bTrackSize -= aTrackSizeIntervaled - aTrackSize\n            aTrackSize = aTrackSizeIntervaled\n        }\n\n        if (aTrackSize < this.minSizeStart) {\n            aTrackSize = this.minSizeStart\n        }\n\n        if (bTrackSize < this.minSizeEnd) {\n            bTrackSize = this.minSizeEnd\n        }\n\n        if (this.trackTypes[this.aTrack] === 'px') {\n            this.tracks[this.aTrack] = `${aTrackSize}px`\n        } else if (this.trackTypes[this.aTrack] === 'fr') {\n            if (this.totalFrs === 1) {\n                this.tracks[this.aTrack] = '1fr'\n            } else {\n                const targetFr = aTrackSize / this.frToPixels\n                this.tracks[this.aTrack] = `${targetFr}fr`\n            }\n        } else if (this.trackTypes[this.aTrack] === '%') {\n            const targetPercentage = aTrackSize / this.percentageToPixels\n            this.tracks[this.aTrack] = `${targetPercentage}%`\n        }\n\n        if (this.trackTypes[this.bTrack] === 'px') {\n            this.tracks[this.bTrack] = `${bTrackSize}px`\n        } else if (this.trackTypes[this.bTrack] === 'fr') {\n            if (this.totalFrs === 1) {\n                this.tracks[this.bTrack] = '1fr'\n            } else {\n                const targetFr = bTrackSize / this.frToPixels\n                this.tracks[this.bTrack] = `${targetFr}fr`\n            }\n        } else if (this.trackTypes[this.bTrack] === '%') {\n            const targetPercentage = bTrackSize / this.percentageToPixels\n            this.tracks[this.bTrack] = `${targetPercentage}%`\n        }\n\n        const style = this.tracks.join(' ')\n        this.writeStyle(this.grid, this.gridTemplateProp, style)\n        this.onDrag(this.direction, this.track, style)\n    }\n\n    cleanup() {\n        window.removeEventListener('mouseup', this.stopDragging)\n        window.removeEventListener('touchend', this.stopDragging)\n        window.removeEventListener('touchcancel', this.stopDragging)\n        window.removeEventListener('mousemove', this.drag)\n        window.removeEventListener('touchmove', this.drag)\n\n        if (this.grid) {\n            this.grid.removeEventListener('selectstart', NOOP)\n            this.grid.removeEventListener('dragstart', NOOP)\n\n            this.grid.style.userSelect = ''\n            this.grid.style.webkitUserSelect = ''\n            this.grid.style.MozUserSelect = ''\n            this.grid.style.pointerEvents = ''\n\n            this.grid.style.cursor = ''\n        }\n\n        window.document.body.style.cursor = ''\n    }\n\n    destroy(immediate = true, cb) {\n        if (immediate || this.dragging === false) {\n            this.cleanup()\n            if (this.element) {\n                this.element.removeEventListener(\n                    'mousedown',\n                    this.startDragging,\n                )\n                this.element.removeEventListener(\n                    'touchstart',\n                    this.startDragging,\n                )\n            }\n\n            if (cb) {\n                cb()\n            }\n        } else {\n            this.needsDestroy = true\n            if (cb) {\n                this.destroyCb = cb\n            }\n        }\n    }\n}\n\nconst getTrackOption = (options, track, defaultValue) => {\n    if (track in options) {\n        return options[track]\n    }\n\n    return defaultValue\n}\n\nconst createGutter = (direction, options) => gutterOptions => {\n    if (gutterOptions.track < 1) {\n        throw Error(\n            `Invalid track index: ${\n                gutterOptions.track\n            }. Track must be between two other tracks.`,\n        )\n    }\n\n    const trackMinSizes =\n        direction === 'column' ? options.columnMinSizes : options.rowMinSizes\n    const trackMinSize = direction === 'column' ? 'columnMinSize' : 'rowMinSize'\n\n    return new Gutter(\n        direction,\n        {\n            minSizeStart: getTrackOption(\n                trackMinSizes,\n                gutterOptions.track - 1,\n                getOption(\n                    options,\n                    trackMinSize,\n                    getOption(options, 'minSize', 0),\n                ),\n            ),\n            minSizeEnd: getTrackOption(\n                trackMinSizes,\n                gutterOptions.track + 1,\n                getOption(\n                    options,\n                    trackMinSize,\n                    getOption(options, 'minSize', 0),\n                ),\n            ),\n            ...gutterOptions,\n        },\n        options,\n    )\n}\n\nclass Grid {\n    constructor(options) {\n        this.options = options\n\n        this.columnGutters = {}\n        this.rowGutters = {}\n\n        const defaultOptions = {\n            columnGutters: options.columnGutters || [],\n            rowGutters: options.rowGutters || [],\n            columnMinSizes: options.columnMinSizes || {},\n            rowMinSizes: options.rowMinSizes || {},\n            ...options,\n        }\n\n        options.columnGutters.forEach(gutterOptions => {\n            this.columnGutters[options.track] = createGutter(\n                'column',\n                defaultOptions,\n            )(gutterOptions)\n        })\n\n        options.rowGutters.forEach(gutterOptions => {\n            this.rowGutters[options.track] = createGutter(\n                'row',\n                defaultOptions,\n            )(gutterOptions)\n        })\n    }\n\n    addColumnGutter(element, track) {\n        if (this.columnGutters[track]) {\n            this.columnGutters[track].destroy()\n        }\n\n        this.columnGutters[track] = createGutter('column', this.options)({\n            element,\n            track,\n        })\n    }\n\n    addRowGutter(element, track) {\n        if (this.rowGutters[track]) {\n            this.rowGutters[track].destroy()\n        }\n\n        this.rowGutters[track] = createGutter('row', this.options)({\n            element,\n            track,\n        })\n    }\n\n    removeColumnGutter(track, immediate = true) {\n        if (this.columnGutters[track]) {\n            this.columnGutters[track].destroy(immediate, () => {\n                delete this.columnGutters[track]\n            })\n        }\n    }\n\n    removeRowGutter(track, immediate = true) {\n        if (this.rowGutters[track]) {\n            this.rowGutters[track].destroy(immediate, () => {\n                delete this.rowGutters[track]\n            })\n        }\n    }\n\n    handleDragStart(e, direction, track) {\n        if (direction === 'column') {\n            if (this.columnGutters[track]) {\n                this.columnGutters[track].destroy()\n            }\n\n            this.columnGutters[track] = createGutter('column', this.options)({\n                track,\n            })\n            this.columnGutters[track].startDragging(e)\n        } else if (direction === 'row') {\n            if (this.rowGutters[track]) {\n                this.rowGutters[track].destroy()\n            }\n\n            this.rowGutters[track] = createGutter('row', this.options)({\n                track,\n            })\n            this.rowGutters[track].startDragging(e)\n        }\n    }\n\n    destroy(immediate = true) {\n        Object.keys(this.columnGutters).forEach(track =>\n            this.columnGutters[track].destroy(immediate, () => {\n                delete this.columnGutters[track]\n            }),\n        )\n        Object.keys(this.rowGutters).forEach(track =>\n            this.rowGutters[track].destroy(immediate, () => {\n                delete this.rowGutters[track]\n            }),\n        )\n    }\n}\n\nexport default options => new Grid(options)\n"],"names":["const","getStyles","rule","ownRules","matchedRules","map","r","style","filter","undefined","getTrackValues","unit","sizes","reduce","accum","size","i","endsWith","Number","slice","length","firstNonZero","obj","keys","Object","getMatchedCSSRules","el","concat","ref","Array","from","ownerDocument","styleSheets","s","let","rules","cssRules","e","matches","selectorText","NOOP","defaultWriteStyle","element","gridTemplateProp","getOption","options","propName","def","value","Gutter","direction","parentOptions","this","track","trackTypes","gridGapProp","cursor","snapOffset","dragInterval","clientAxis","optionStyle","onDragStart","onDragEnd","onDrag","writeStyle","startDragging","bind","stopDragging","drag","minSizeStart","minSizeEnd","addEventListener","getDimensions","grid","getBoundingClientRect","start","top","end","bottom","height","left","right","width","getSizeAtTrack","index","tracks","computedPixels","gap","computedGapPixels","newIndex","getSizeOfTrack","getRawTracks","Error","getGap","getRawComputedTracks","window","getComputedStyle","getRawComputedGap","setTracks","raw","split","setComputedTracks","computedTracks","setGap","setComputedGap","computedGap","getMousePosition","touches","button","preventDefault","parentNode","target","trackPercentage","trackFr","totalFrs","frToPixels","percentageToPixels","gutterStart","dragStartOffset","aTrack","bTrack","aTrackStart","bTrackEnd","dragging","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","document","body","cleanup","needsDestroy","removeEventListener","destroyCb","mousePosition","gutterSize","minMousePosition","maxMousePosition","aTrackSize","bTrackSize","aTrackSizeIntervaled","Math","round","targetFr","targetPercentage","targetFr$1","targetPercentage$1","join","destroy","immediate","cb","getTrackOption","defaultValue","createGutter","gutterOptions","trackMinSizes","columnMinSizes","rowMinSizes","trackMinSize","Grid","columnGutters","rowGutters","defaultOptions","forEach","this$1","addColumnGutter","addRowGutter","removeColumnGutter","removeRowGutter","handleDragStart"],"mappings":"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"}